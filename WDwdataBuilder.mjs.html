<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>WDwdataBuilder.mjs - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#WDwdataBuilder">WDwdataBuilder</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">WDwdataBuilder.mjs</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import get from 'lodash-es/get.js'
import size from 'lodash-es/size.js'
import iseobj from 'wsemi/src/iseobj.mjs'
import isestr from 'wsemi/src/isestr.mjs'
import isfun from 'wsemi/src/isfun.mjs'
import ispm from 'wsemi/src/ispm.mjs'
import str2b64 from 'wsemi/src/str2b64.mjs'
import ltdtDiffByKey from 'wsemi/src/ltdtDiffByKey.mjs'
import evem from 'wsemi/src/evem.mjs'
import pmSeries from 'wsemi/src/pmSeries.mjs'
import delay from 'wsemi/src/delay.mjs'
import fsIsFolder from 'wsemi/src/fsIsFolder.mjs'
import fsCleanFolder from 'wsemi/src/fsCleanFolder.mjs'
import fsCreateFolder from 'wsemi/src/fsCreateFolder.mjs'
import fsCopyFolder from 'wsemi/src/fsCopyFolder.mjs'
import fsTaskCp from 'wsemi/src/fsTaskCp.mjs'
import ot from 'dayjs'
import _srlog from './srlog.mjs'


/**
 * 下載數據建構器
 *
 * @param {Object} [opt={}] 輸入設定物件，預設{}
 * @param {String} [opt.keyId] 輸入各筆數據之主鍵字串，預設keyId
 * @param {String} [opt.fdDwAttime] 輸入當前下載數據資料夾字串，預設'./_dwAttime'
 * @param {String} [opt.fdDwCurrent] 輸入已下載數據資料夾字串，預設'./_dwCurrent'
 * @param {String} [opt.fdResult] 輸入已下載數據所連動生成數據資料夾字串，預設'./_result'
 * @param {String} [opt.fdTaskCpSrc] 輸入任務狀態之來源端資料夾字串，預設'./_taskCpSrc'
 * @param {Function} [opt.funDownload] 輸入自定義下載函數，回傳資料陣列
 * @param {Function} [opt.funGetCurrent] 輸入自定義取得當前資料函數，回傳資料陣列
 * @param {Function} [opt.funAdd] 輸入當有新資料時，需要連動處理之函數
 * @param {Function} [opt.funModify] 輸入當有資料需更新時，需要連動處理之函數
 * @param {Function} [opt.funRemove] 輸入當有資料需刪除時，需要連動處理之函數
 * @returns {Object} 回傳事件物件，可呼叫函數on監聽change事件
 * @example
 *
 * //fdDwAttime
 * let fdDwAttime = `./_dwAttime`
 * w.fsCleanFolder(fdDwAttime)
 *
 * //fdDwCurrent
 * let fdDwCurrent = `./_dwCurrent`
 * w.fsCleanFolder(fdDwCurrent)
 *
 * //fdResult
 * let fdResult = './_result'
 * w.fsCleanFolder(fdResult)
 *
 * //funDownload
 * let funDownload = async() => {
 *
 *     //reverse
 *     let items = [
 *         {
 *             'id': '114115',
 *             'tag': '2025082116374751115',
 *             'number': '115',
 *             'time': '2025-08-21T16:37:47+08:00',
 *             'timeRec': '2025-08-21 16:37:47',
 *             'timeTag': '20250821163747',
 *             'ml': '5.1',
 *         },
 *         {
 *             'id': '114116',
 *             'tag': '2025082214061554116',
 *             'number': '116',
 *             'time': '2025-08-22T14:06:15+08:00',
 *             'timeRec': '2025-08-22 14:06:15',
 *             'timeTag': '20250822140615',
 *             'ml': '5.4',
 *         },
 *     ]
 *
 *     _.each(items, (v) => {
 *
 *         let fp = `${fdDwAttime}/${v.id}.json`
 *
 *         fs.writeFileSync(fp, JSON.stringify(v), 'utf8')
 *
 *     })
 *
 *     return items
 * }
 *
 * //funGetCurrent
 * let funGetCurrent = async() => {
 *
 *     //vfps
 *     let vfps = w.fsTreeFolder(fdDwCurrent, 1)
 *     // console.log('vfps', vfps)
 *
 *     //items
 *     let items = []
 *     _.each(vfps, (v) => {
 *
 *         let j = fs.readFileSync(v.path, 'utf8')
 *         let item = JSON.parse(j)
 *
 *         items.push(item)
 *
 *     })
 *
 *     return items
 * }
 *
 * //funRemove
 * let funRemove = async(v) => {
 *
 *     let fd = `${fdResult}/${v.id}`
 *
 *     if (w.fsIsFolder(fd)) {
 *         w.fsDeleteFolder(fd)
 *     }
 *
 * }
 *
 * //funAdd
 * let funAdd = async(v) => {
 *
 *     let fd = `${fdResult}/${v.id}`
 *
 *     if (w.fsIsFolder(fd)) {
 *         w.fsCleanFolder(fd)
 *     }
 *
 *     //do somethings
 *
 * }
 *
 * //funModify
 * let funModify = async(v) => {
 *
 *     let fd = `${fdResult}/${v.id}`
 *
 *     if (w.fsIsFolder(fd)) {
 *         w.fsCleanFolder(fd)
 *     }
 *
 *     //do somethings
 *
 * }
 *
 * let opt = {
 *     funDownload,
 *     funGetCurrent,
 *     funRemove,
 *     funAdd,
 *     funModify,
 * }
 * let ev = await WDwdataBuilder(opt)
 *     .catch((err) => {
 *         console.log(err)
 *     })
 * ev.on('change', (msg) => {
 *     delete msg.type
 *     console.log('change', msg)
 * })
 * // change { event: 'start', msg: 'running...' }
 * // change { event: 'proc-callfun-download', msg: 'start...' }
 * // change { event: 'proc-callfun-download', msg: 'done' }
 * // change { event: 'proc-callfun-getCurrent', msg: 'start...' }
 * // change { event: 'proc-callfun-getCurrent', msg: 'done' }
 * // change { event: 'compare', msg: 'start...' }
 * // change { event: 'compare', msg: 'done' }
 * // change { event: 'proc-add-callfun-add', id: '114116', msg: 'start...' }
 * // change { event: 'proc-add-callfun-add', id: '114116', msg: 'done' }
 * // change { event: 'proc-add-callfun-add', id: '114115', msg: 'start...' }
 * // change { event: 'proc-add-callfun-add', id: '114115', msg: 'done' }
 * // change {
 * //   event: 'end',
 * //   timeRunStart: '2025-08-23T15:47:24+08:00',
 * //   timeRunEnd: '2025-08-23T15:47:24+08:00',
 * //   timeRunSpent: '0s',
 * //   msg: 'done'
 * // }
 *
 */
let WDwdataBuilder = async(opt = {}) => {

    //keyId
    let keyId = get(opt, 'keyId')
    if (!isestr(keyId)) {
        keyId = `id`
    }

    //fdDwAttime
    let fdDwAttime = get(opt, 'fdDwAttime')
    if (!isestr(fdDwAttime)) {
        fdDwAttime = `./_dwAttime`
    }
    if (!fsIsFolder(fdDwAttime)) {
        fsCreateFolder(fdDwAttime)
    }

    //fdDwCurrent
    let fdDwCurrent = get(opt, 'fdDwCurrent')
    if (!isestr(fdDwCurrent)) {
        fdDwCurrent = `./_dwCurrent`
    }
    if (!fsIsFolder(fdDwCurrent)) {
        fsCreateFolder(fdDwCurrent)
    }

    //fdResult
    let fdResult = get(opt, 'fdResult')
    if (!isestr(fdResult)) {
        fdResult = './_result'
    }
    if (!fsIsFolder(fdResult)) {
        fsCreateFolder(fdResult)
    }

    //fdTaskCpSrc
    let fdTaskCpSrc = get(opt, 'fdTaskCpSrc')
    if (!isestr(fdTaskCpSrc)) {
        fdTaskCpSrc = './_taskCpSrc'
    }
    if (!fsIsFolder(fdTaskCpSrc)) {
        fsCreateFolder(fdTaskCpSrc)
    }

    //funDownload
    let funDownload = get(opt, 'funDownload')
    if (!isfun(funDownload)) {
        throw new Error(`invalid funDownload`)
    }

    //funGetCurrent
    let funGetCurrent = get(opt, 'funGetCurrent')
    if (!isfun(funGetCurrent)) {
        throw new Error(`invalid funGetCurrent`)
    }

    //funAdd
    let funAdd = get(opt, 'funAdd')
    if (!isfun(funAdd)) {
        throw new Error(`invalid funAdd`)
    }

    //funModify
    let funModify = get(opt, 'funModify')
    if (!isfun(funModify)) {
        throw new Error(`invalid funModify`)
    }

    //funRemove
    let funRemove = get(opt, 'funRemove')
    if (!isfun(funRemove)) {
        throw new Error(`invalid funRemove`)
    }

    //ev
    let ev = evem()

    //srlog
    let srlog = {
        info: (msg) => {
            _srlog.info(msg)
            ev.emit('change', { type: 'info', ...msg })
        },
        // warn: (msg) => {
        //     _srlog.warn(msg)
        //     ev.emit('warn', msg)
        // },
        error: (msg) => {
            _srlog.error(msg)
            ev.emit('change', { type: 'error', ...msg })
        },
    }

    //core
    let core = async() => {

        //因core執行初期ev尚未回傳給外部監聽, 故須delay延遲脫勾
        await delay(1)

        //ts
        let ts = ot()

        //calcTimeRun
        let calcTimeRun = () => {

            //te
            let te = ot()

            //s
            let s = te.diff(ts, 'second')

            //r
            let r = {
                timeRunStart: ts.format('YYYY-MM-DDTHH:mm:ssZ'),
                timeRunEnd: te.format('YYYY-MM-DDTHH:mm:ssZ'),
                timeRunSpent: `${s}s`,
            }

            return r
        }

        srlog.info({ event: 'start', msg: 'running...' })

        //msgExit
        let msgExit = ''

        //fsTaskCp
        let otk = fsTaskCp(fdTaskCpSrc, fdTaskCpSrc) //因不使用偵測端, 故設定fdTar=fdSrc

        //otkSrc
        let otkSrc = otk.buildSrc()
        // otkSrc.on('set', (msg) => {
        //     // console.log(`src send task...`, msg)
        // })
        // otkSrc.on('remove', (msg) => {
        //     // console.log(`src send task...`, msg)
        // })

        //itemsAtt
        let itemsAtt = []
        if (true) {
            try {

                //funDownload
                srlog.info({ event: 'proc-callfun-download', msg: 'start...' })
                let q = funDownload()
                if (ispm(q)) {
                    q = await q
                }
                srlog.info({ event: 'proc-callfun-download', msg: 'done' })

                //save
                itemsAtt = q

            }
            catch (err) {
                console.log(err)
                srlog.error({ event: 'proc-callfun-download', msg: err.message })
                msgExit = 'error at proc-callfun-download'
            }
        }

        //check
        if (isestr(msgExit)) {
            console.log(`error occurred, task canceled`) //程序發生錯誤, 不進行後續動作
            srlog.info({ event: 'cancel', ...calcTimeRun(), msg: msgExit })
            return
        }

        //itemsCur
        let itemsCur = []
        if (true) {
            try {

                //funGetCurrent
                srlog.info({ event: 'proc-callfun-getCurrent', msg: 'start...' })
                let q = funGetCurrent()
                if (ispm(q)) {
                    q = await q
                }
                srlog.info({ event: 'proc-callfun-getCurrent', msg: 'done' })

                //save
                itemsCur = q

            }
            catch (err) {
                console.log(err)
                srlog.error({ event: 'proc-callfun-getCurrent', msg: err.message })
                msgExit = 'error at proc-callfun-getCurrent'
            }
        }

        //check
        if (isestr(msgExit)) {
            console.log(`error occurred, task canceled`) //程序發生錯誤, 不進行後續動作
            srlog.info({ event: 'cancel', ...calcTimeRun(), msg: msgExit })
            return
        }

        //check
        if (size(itemsAtt) === 0) {
            console.log(`invalid data, task canceled`) //無法取得有效數據, 不進行後續動作
            srlog.info({ event: 'cancel', ...calcTimeRun(), msg: 'can not download data' })
            return
        }

        //check
        if (size(itemsCur) - size(itemsAtt) > 10) {
            console.log(`difference between the data before and after is too large, size(itemsCur)[${size(itemsCur)}]-size(itemsAtt)[${size(itemsAtt)}]>10`) //當前取得數據與已儲存數據之數量差距超過10, 不進行後續動作, 當前取得數據筆數[${size(itemsAtt)}], 已儲存數據筆數[${size(itemsCur)}]
            srlog.info({ event: 'cancel', ...calcTimeRun(), msg: 'difference between the data before and after is too large' })
            return
        }

        //ltdtDiffByKey
        let r = null
        if (true) {
            try {

                srlog.info({ event: 'compare', msg: 'start...' })
                let ltdtSrc = itemsAtt
                let ltdtTar = itemsCur
                r = ltdtDiffByKey(ltdtTar, ltdtSrc, keyId, { withInfor: false })
                // console.log('ltdtDiffByKey', r)
                //   del: [ {...} ],
                //   add: [ {...} ],
                //   same: [ {...} ],
                //   diff: [ {...} ],
                srlog.info({ event: 'compare', msg: 'done' })

            }
            catch (err) {
                console.log(err)
                srlog.error({ event: 'compare', msg: err.message })
            }
        }

        //check
        if (!iseobj(r)) {
            console.log(`can not calculate the difference, task canceled`) //無法計算當前取得與已儲存數據之差異, 不進行後續動作
            srlog.info({ event: 'cancel', ...calcTimeRun(), msg: 'can not calculate the difference between the data before and after' })
            return
        }

        //check
        if (size(r.del) === 0 &amp;&amp; size(r.add) === 0 &amp;&amp; size(r.diff) === 0) {
            console.log(`no difference, task canceled`) //當前取得與已儲存數據無差異, 不進行後續動作
            srlog.info({ event: 'cancel', ...calcTimeRun(), msg: 'no difference' })
            return
        }

        //trigger del
        await pmSeries(r.del, async(v) => {

            //check
            if (isestr(msgExit)) {
                return
            }

            //funRemove
            try {
                srlog.info({ event: 'proc-remove-callfun-remove', [keyId]: v[keyId], msg: 'start...' })
                let q = funRemove(v)
                if (ispm(q)) {
                    q = await q
                }
                // srlog.info({ event: 'proc-remove-callfun-remove', [keyId]: v[keyId], msg: 'done' })
            }
            catch (err) {
                console.log(err)
                srlog.error({ event: 'proc-remove-callfun-remove', [keyId]: v[keyId], msg: err.message })
                msgExit = 'error at proc-remove-callfun-remove'
            }

            //check
            if (isestr(msgExit)) {
                return
            }

            //remove
            try {
                otkSrc.remove(v[keyId])
                srlog.info({ event: 'proc-remove-callfun-remove', [keyId]: v[keyId], msg: 'done' })
            }
            catch (err) {
                console.log(err)
                srlog.error({ event: 'proc-remove-otk-remove', [keyId]: v[keyId], msg: err.message })
                msgExit = 'error at proc-remove-otk-remove'
            }

        })

        //check
        if (isestr(msgExit)) {
            console.log(`error occurred, task canceled`) //程序發生錯誤, 不進行後續動作
            srlog.info({ event: 'cancel', ...calcTimeRun(), msg: msgExit })
            return
        }

        //trigger add
        await pmSeries(r.add, async(v) => {

            //check
            if (isestr(msgExit)) {
                return
            }

            //funAdd
            try {
                srlog.info({ event: 'proc-add-callfun-add', [keyId]: v[keyId], msg: 'start...' })
                let q = funAdd(v)
                if (ispm(q)) {
                    q = await q
                }
                // srlog.info({ event: 'proc-add-callfun-add', [keyId]: v[keyId], msg: 'done' })
            }
            catch (err) {
                console.log(err)
                srlog.error({ event: 'proc-add-callfun-add', [keyId]: v[keyId], msg: err.message })
                msgExit = 'error at proc-add-callfun-add'
            }

            //check
            if (isestr(msgExit)) {
                return
            }

            //set
            try {
                let hash = str2b64(JSON.stringify(v))
                otkSrc.set(v[keyId], hash)
                srlog.info({ event: 'proc-add-callfun-add', [keyId]: v[keyId], msg: 'done' })
            }
            catch (err) {
                console.log(err)
                srlog.error({ event: 'proc-add-otk-set', [keyId]: v[keyId], msg: err.message })
                msgExit = 'error at proc-add-otk-set'
            }

        })

        //check
        if (isestr(msgExit)) {
            console.log(`error occurred, task canceled`) //程序發生錯誤, 不進行後續動作
            srlog.info({ event: 'cancel', ...calcTimeRun(), msg: msgExit })
            return
        }

        //trigger diff
        await pmSeries(r.diff, async(v) => {

            //check
            if (isestr(msgExit)) {
                return
            }

            //funModify
            try {
                srlog.info({ event: 'proc-diff-callfun-modify', [keyId]: v[keyId], msg: 'start...' })
                let q = funModify(v)
                if (ispm(q)) {
                    q = await q
                }
                // srlog.info({ event: 'proc-diff-callfun-modify', [keyId]: v[keyId], msg: 'done' })
            }
            catch (err) {
                console.log(err)
                srlog.error({ event: 'proc-diff-callfun-modify', [keyId]: v[keyId], msg: err.message })
                msgExit = 'error at proc-diff-callfun-modify'
            }

            //check
            if (isestr(msgExit)) {
                return
            }

            //set
            try {
                let hash = str2b64(JSON.stringify(v))
                otkSrc.set(v[keyId], hash)
                srlog.info({ event: 'proc-diff-callfun-modify', [keyId]: v[keyId], msg: 'done' })
            }
            catch (err) {
                console.log(err)
                srlog.error({ event: 'proc-diff-otk-set', [keyId]: v[keyId], msg: err.message })
                msgExit = 'error at proc-diff-otk-set'
            }

        })

        //check
        if (isestr(msgExit)) {
            console.log(`error occurred, task canceled`) //程序發生錯誤, 不進行後續動作
            srlog.info({ event: 'cancel', ...calcTimeRun(), msg: msgExit })
            return
        }

        //成功處理完畢, 將fdDwAttime儲存至fdDwCurrent
        if (true) {

            //fsCleanFolder
            fsCleanFolder(fdDwCurrent)

            //fsCopyFolder
            let r = fsCopyFolder(fdDwAttime, fdDwCurrent)

            //check
            if (r.error) {
                console.log(r.error)
                srlog.error({ event: 'task-update-rawData', msg: r.error })
                msgExit = 'error at task-update-rawData'
                return
            }

        }

        //check
        if (isestr(msgExit)) {
            console.log(`error occurred, task canceled`) //程序發生錯誤, 不進行後續動作
            srlog.info({ event: 'cancel', ...calcTimeRun(), msg: msgExit })
            return
        }

        srlog.info({ event: 'end', ...calcTimeRun(), msg: 'done' })

    }

    core()
        .catch((err) => {
            console.log(err)
            srlog.error({ event: 'proc-core', msg: err.message })
        })

    //save
    ev.srlog = srlog

    return ev
}


export default WDwdataBuilder
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.4</a> on Sun Aug 24 2025 23:28:10 GMT+0800 (台北標準時間) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
