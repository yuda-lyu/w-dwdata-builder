<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>WDwdataBuilder.mjs - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#WDwdataBuilder">WDwdataBuilder</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">WDwdataBuilder.mjs</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import fs from 'fs'
import get from 'lodash-es/get.js'
import size from 'lodash-es/size.js'
import iseobj from 'wsemi/src/iseobj.mjs'
import isestr from 'wsemi/src/isestr.mjs'
import isp0int from 'wsemi/src/isp0int.mjs'
import isbol from 'wsemi/src/isbol.mjs'
import isfun from 'wsemi/src/isfun.mjs'
import ispm from 'wsemi/src/ispm.mjs'
import cdbl from 'wsemi/src/cdbl.mjs'
import str2b64 from 'wsemi/src/str2b64.mjs'
import ltdtDiffByKey from 'wsemi/src/ltdtDiffByKey.mjs'
import now2str from 'wsemi/src/now2str.mjs'
import evem from 'wsemi/src/evem.mjs'
import pmSeries from 'wsemi/src/pmSeries.mjs'
import delay from 'wsemi/src/delay.mjs'
import waitFun from 'wsemi/src/waitFun.mjs'
import getErrorMessage from 'wsemi/src/getErrorMessage.mjs'
import fsIsFile from 'wsemi/src/fsIsFile.mjs'
import fsIsFolder from 'wsemi/src/fsIsFolder.mjs'
import fsDeleteFile from 'wsemi/src/fsDeleteFile.mjs'
import fsCleanFolder from 'wsemi/src/fsCleanFolder.mjs'
import fsCreateFolder from 'wsemi/src/fsCreateFolder.mjs'
import fsCopyFolder from 'wsemi/src/fsCopyFolder.mjs'
import fsTaskCp from 'wsemi/src/fsTaskCp.mjs'
import fsTreeFolder from 'wsemi/src/fsTreeFolder.mjs'
import WSyslog from 'w-syslog/src/WSyslog.mjs'
import ot from 'dayjs'


/**
 * 下載數據建構器
 *
 * @param {Object} [opt={}] 輸入設定物件，預設{}
 * @param {String} [opt.keyId='keyId'] 輸入各筆數據之主鍵字串，預設'keyId'
 * @param {String} [opt.fdDwAttime='./_dwAttime'] 輸入當前下載數據資料夾字串，預設'./_dwAttime'
 * @param {String} [opt.fdDwCurrent='./_dwCurrent'] 輸入已下載數據資料夾字串，預設'./_dwCurrent'
 * @param {String} [opt.fdResult='./_result'] 輸入已下載數據所連動生成數據資料夾字串，預設'./_result'
 * @param {String} [opt.fdTaskCpActualSrc='./_taskCpActualSrc'] 輸入任務狀態之來源端資料夾字串，預設'./_taskCpActualSrc'
 * @param {String} [opt.fdTaskCpSrc='./_taskCpSrc'] 輸入任務狀態之來源端資料夾字串，預設'./_taskCpSrc'
 * @param {String} [opt.fdLog='./_logs'] 輸入儲存log資料夾字串，預設'./_logs'
 * @param {Function} [opt.funDownload=null] 輸入自定義當前下載之hash數據處理函數，回傳資料陣列，預設null
 * @param {Function} [opt.funGetCurrent=null] 輸入自定義已下載之hash數據處理函數，回傳資料陣列，預設null
 * @param {Function} [opt.funAdd=null] 輸入當有新資料時，需要連動處理之函數，預設null
 * @param {Function} [opt.funModify=null] 輸入當有資料需更新時，需要連動處理之函數，預設null
 * @param {Function} [opt.funRemove=null] 輸入當有資料需刪除時，需要連動處理之函數，預設null
 * @param {Number} [opt.timeToleranceRemove=0] 輸入刪除任務之防抖時長，單位ms，預設0，代表不使用
 * @returns {Object} 回傳事件物件，可呼叫函數on監聽change事件，可呼叫函數srlog額外進行事件紀錄
 * @example
 *
 * //fdDwAttime
 * let fdDwAttime = `./_dwAttime`
 * w.fsCleanFolder(fdDwAttime)
 *
 * //fdDwCurrent
 * let fdDwCurrent = `./_dwCurrent`
 * w.fsCleanFolder(fdDwCurrent)
 *
 * //fdResult
 * let fdResult = './_result'
 * w.fsCleanFolder(fdResult)
 *
 * //funDownload
 * let funDownload = async() => {
 *
 *     //items
 *     let items = [
 *         {
 *             'id': '114115',
 *             'tag': '2025082116374751115',
 *             'number': '115',
 *             'time': '2025-08-21T16:37:47+08:00',
 *             'timeRec': '2025-08-21 16:37:47',
 *             'timeTag': '20250821163747',
 *             'ml': '5.1',
 *         },
 *         {
 *             'id': '114116',
 *             'tag': '2025082214061554116',
 *             'number': '116',
 *             'time': '2025-08-22T14:06:15+08:00',
 *             'timeRec': '2025-08-22 14:06:15',
 *             'timeTag': '20250822140615',
 *             'ml': '5.4',
 *         },
 *     ]
 *
 *     _.each(items, (v) => {
 *
 *         let fp = `${fdDwAttime}/${v.id}.json`
 *
 *         fs.writeFileSync(fp, JSON.stringify(v), 'utf8')
 *
 *     })
 *
 *     return items
 * }
 *
 * //funGetCurrent
 * let funGetCurrent = async() => {
 *
 *     //vfps
 *     let vfps = w.fsTreeFolder(fdDwCurrent, 1)
 *     // console.log('vfps', vfps)
 *
 *     //items
 *     let items = []
 *     _.each(vfps, (v) => {
 *
 *         let j = fs.readFileSync(v.path, 'utf8')
 *         let item = JSON.parse(j)
 *
 *         items.push(item)
 *
 *     })
 *
 *     return items
 * }
 *
 * //funRemove
 * let funRemove = async(v) => {
 *
 *     let fd = `${fdResult}/${v.id}`
 *
 *     if (w.fsIsFolder(fd)) {
 *         w.fsDeleteFolder(fd)
 *     }
 *
 * }
 *
 * //funAdd
 * let funAdd = async(v) => {
 *
 *     let fd = `${fdResult}/${v.id}`
 *
 *     if (w.fsIsFolder(fd)) {
 *         w.fsCleanFolder(fd)
 *     }
 *
 *     //do somethings
 *
 * }
 *
 * //funModify
 * let funModify = async(v) => {
 *
 *     let fd = `${fdResult}/${v.id}`
 *
 *     if (w.fsIsFolder(fd)) {
 *         w.fsCleanFolder(fd)
 *     }
 *
 *     //do somethings
 *
 * }
 *
 * let opt = {
 *     funDownload,
 *     funGetCurrent,
 *     funRemove,
 *     funAdd,
 *     funModify,
 * }
 * let ev = await WDwdataBuilder(opt)
 *     .catch((err) => {
 *         console.log(err)
 *     })
 * ev.on('change', (msg) => {
 *     delete msg.type
 *     delete msg.timeRunStart
 *     delete msg.timeRunEnd
 *     delete msg.timeRunSpent
 *     console.log('change', msg)
 * })
 * // change { event: 'start', msg: 'running...' }
 * // change { event: 'proc-callfun-download', msg: 'start...' }
 * // change { event: 'proc-callfun-download', num: 2, msg: 'done' }
 * // change { event: 'proc-callfun-getCurrent', msg: 'start...' }
 * // change { event: 'proc-callfun-getCurrent', num: 0, msg: 'done' }
 * // change { event: 'compare', msg: 'start...' }
 * // change { event: 'compare', msg: 'done' }
 * // change { event: 'proc-add-callfun-add', id: '114116', msg: 'start...' }
 * // change { event: 'proc-add-callfun-add', id: '114116', msg: 'done' }
 * // change { event: 'proc-add-callfun-add', id: '114115', msg: 'start...' }
 * // change { event: 'proc-add-callfun-add', id: '114115', msg: 'done' }
 * // change { event: 'end', msg: 'done' }
 *
 */
let WDwdataBuilder = async(opt = {}) => {

    //keyId
    let keyId = get(opt, 'keyId')
    if (!isestr(keyId)) {
        keyId = `id`
    }

    //fdDwAttime
    let fdDwAttime = get(opt, 'fdDwAttime')
    if (!isestr(fdDwAttime)) {
        fdDwAttime = `./_dwAttime`
    }
    if (!fsIsFolder(fdDwAttime)) {
        fsCreateFolder(fdDwAttime)
    }

    //fdDwCurrent
    let fdDwCurrent = get(opt, 'fdDwCurrent')
    if (!isestr(fdDwCurrent)) {
        fdDwCurrent = `./_dwCurrent`
    }
    if (!fsIsFolder(fdDwCurrent)) {
        fsCreateFolder(fdDwCurrent)
    }

    // //fdTagAdd
    // let fdTagAdd = get(opt, 'fdTagAdd')
    // if (!isestr(fdTagAdd)) {
    //     fdTagAdd = './_tagAdd'
    // }
    // // if (!fsIsFolder(fdTagAdd)) {
    // //     fsCreateFolder(fdTagAdd)
    // // }

    // //fdTagModify
    // let fdTagModify = get(opt, 'fdTagModify')
    // if (!isestr(fdTagModify)) {
    //     fdTagModify = './_tagModify'
    // }

    //fdTagRemove
    let fdTagRemove = get(opt, 'fdTagRemove')
    if (!isestr(fdTagRemove)) {
        fdTagRemove = './_tagRemove'
    }

    //fdResult
    let fdResult = get(opt, 'fdResult')
    if (!isestr(fdResult)) {
        fdResult = './_result'
    }
    if (!fsIsFolder(fdResult)) {
        fsCreateFolder(fdResult)
    }

    //fdTaskCpActualSrc
    let fdTaskCpActualSrc = get(opt, 'fdTaskCpActualSrc')
    if (!isestr(fdTaskCpActualSrc)) {
        fdTaskCpActualSrc = './_taskCpActualSrc'
    }
    if (!fsIsFolder(fdTaskCpActualSrc)) {
        fsCreateFolder(fdTaskCpActualSrc)
    }

    //fdTaskCpSrc
    let fdTaskCpSrc = get(opt, 'fdTaskCpSrc')
    if (!isestr(fdTaskCpSrc)) {
        fdTaskCpSrc = './_taskCpSrc'
    }
    if (!fsIsFolder(fdTaskCpSrc)) {
        fsCreateFolder(fdTaskCpSrc)
    }

    //fdLog
    let fdLog = get(opt, 'fdLog')
    if (!isestr(fdLog)) {
        fdLog = './_logs'
    }
    if (!fsIsFolder(fdLog)) {
        fsCreateFolder(fdLog)
    }

    //funDownload
    let funDownload = get(opt, 'funDownload')
    if (!isfun(funDownload)) {
        throw new Error(`invalid funDownload`)
    }

    //funGetCurrent
    let funGetCurrent = get(opt, 'funGetCurrent')
    if (!isfun(funGetCurrent)) {
        throw new Error(`invalid funGetCurrent`)
    }

    //funAdd
    let funAdd = get(opt, 'funAdd')
    if (!isfun(funAdd)) {
        throw new Error(`invalid funAdd`)
    }

    //funModify
    let funModify = get(opt, 'funModify')
    if (!isfun(funModify)) {
        throw new Error(`invalid funModify`)
    }

    //funRemove
    let funRemove = get(opt, 'funRemove')
    if (!isfun(funRemove)) {
        throw new Error(`invalid funRemove`)
    }

    // //timeToleranceAdd
    // let timeToleranceAdd = get(opt, 'timeToleranceAdd')
    // if (!isp0int(timeToleranceAdd)) {
    //     timeToleranceAdd = 60 * 60 * 1000
    // }
    // timeToleranceAdd = cdbl(timeToleranceAdd)

    // //timeToleranceModify
    // let timeToleranceModify = get(opt, 'timeToleranceModify')
    // if (!isp0int(timeToleranceModify)) {
    //     timeToleranceModify = 60 * 60 * 1000
    // }
    // timeToleranceModify = cdbl(timeToleranceModify)

    //timeToleranceRemove
    let timeToleranceRemove = get(opt, 'timeToleranceRemove')
    if (!isp0int(timeToleranceRemove)) {
        timeToleranceRemove = 0
    }
    timeToleranceRemove = cdbl(timeToleranceRemove)

    //延遲偵測是否創建資料夾
    // if (timeToleranceModify >= 0 &amp;&amp; !fsIsFolder(fdTagModify)) {
    //     fsCreateFolder(fdTagModify)
    // }
    if (timeToleranceRemove > 0 &amp;&amp; !fsIsFolder(fdTagRemove)) {
        fsCreateFolder(fdTagRemove)
    }

    //ev
    let ev = evem()

    //_srlog
    let _srlog = WSyslog({
        fdLog,
        interval: 'hr',
    })

    //srlog
    let srlog = {
        info: (msg) => {
            _srlog.info(msg)
            ev.emit('change', { type: 'info', ...msg })
        },
        warn: (msg) => {
            _srlog.warn(msg)
            ev.emit('change', { type: 'warn', ...msg })
        },
        error: (msg) => {
            _srlog.error(msg)
            ev.emit('change', { type: 'error', ...msg })
        },
    }

    //tagCore
    let tagCore = async (mode, fn, hash = '') => {

        //fdTag
        let fdTag = ''
        if (mode === 'add') {
            // fdTag = fdTagAdd
            throw new Error(`does not support add`)
        }
        else if (mode === 'modify') {
            // fdTag = fdTagModify
            throw new Error(`does not support modify`)
        }
        else if (mode === 'remove') {
            fdTag = fdTagRemove
        }
        else {
            throw new Error(`invalid mode[${mode}]`)
        }

        //fp, 增加/變更/刪除清單資料夾內之檔案路徑
        let fp = `${fdTag}/${fn}`

        // //check, 防抖要能刷新起算時間, 故要持續writeFileSync
        // if (fsIsFile(fp)) {
        //     return
        // }

        //o
        let o = {
            time: now2str(),
            hash,
        }

        //writeFileSync
        fs.writeFileSync(fp, JSON.stringify(o), 'utf8')

    }

    // //tagAdd
    // let tagAdd = async (fn) => {
    //     let r = await tagCore('add', fn)
    //     return r
    // }

    // //tagModify
    // let tagModify = async (fn, hash) => {
    //     let r = await tagCore('modify', fn, hash)
    //     return r
    // }

    //tagRemove
    let tagRemove = async (fn) => {
        let r = await tagCore('remove', fn)
        return r
    }

    //checkTagCore
    let checkTagCore = async (mode, fn, opt = {}) => {

        //checkTime
        let checkTime = get(opt, 'checkTime')
        if (!isbol(checkTime)) {
            checkTime = true
        }

        //timeNow
        let timeNow = get(opt, 'timeNow')

        //fdTag, timeTolerance
        let fdTag = ''
        let timeTolerance = 0
        if (mode === 'add') {
            // fdTag = fdTagAdd
            // timeTolerance = timeToleranceAdd
            throw new Error(`does not support add`)
        }
        else if (mode === 'modify') {
            // fdTag = fdTagModify
            // timeTolerance = timeToleranceModify
            throw new Error(`does not support modify`)
        }
        else if (mode === 'remove') {
            fdTag = fdTagRemove
            timeTolerance = timeToleranceRemove
        }
        else {
            throw new Error(`invalid mode[${mode}]`)
        }

        //fp, 增加/變更/刪除清單資料夾內之檔案路徑
        let fp = `${fdTag}/${fn}`

        //check, 預期要有檔案, 若無檔案無法讀取內容
        if (!fsIsFile(fp)) {
            return {
                b: false,
                msg: `fp[${fp}] is not a file`,
            }
        }

        //checkTime
        if (!checkTime) {
            return {
                b: true,
                msg: `fp[${fp}] exists`,
            }
        }

        //check
        if (!iseobj(timeNow)) {
            throw new Error(`invalid timeNow`) //預期調用checkTagCore時若checkTime=true就一定要給timeNow, 沒給就報錯確保程式一定要通過單元測試
        }

        //j
        let j = fs.readFileSync(fp, 'utf8')

        //o
        let o = JSON.parse(j)

        //time
        let time = get(o, 'time')

        //ts
        let ts = ot(time)

        //te
        let te = timeNow

        //num
        let num = te.diff(ts, 'millisecond')

        //b
        let b = num >= timeTolerance
        // console.log(mode, fn, `num[${num}] >= timeTolerance[${timeTolerance}]`, b, 'checkTime', checkTime)
        if (b) {
            return {
                b,
                msg: `time difference[${num}] >= time tolerance[${timeTolerance}]`,
            }
        }
        else {
            return {
                b,
                msg: `allowable time difference`,
            }
        }
    }

    // //checkTagAdd
    // let checkTagAdd = async (fn, opt = {}) => {
    //     let r = await checkTagCore('add', fn, opt)
    //     return r
    // }

    // //checkTagModify
    // let checkTagModify = async (fn, opt = {}) => {
    //     let r = await checkTagCore('modify', fn, opt)
    //     return r
    // }

    //checkTagRemove
    let checkTagRemove = async (fn, opt = {}) => {
        let r = await checkTagCore('remove', fn, opt)
        return r
    }

    //releaseTagCore
    let releaseTagCore = async (mode, fn) => {

        //fdTag
        let fdTag = ''
        if (mode === 'add') {
            // fdTag = fdTagAdd
            throw new Error(`does not support add`)
        }
        else if (mode === 'modify') {
            // fdTag = fdTagModify
            throw new Error(`does not support modify`)
        }
        else if (mode === 'remove') {
            fdTag = fdTagRemove
        }
        else {
            throw new Error(`invalid mode[${mode}]`)
        }

        //fp, 增加/變更/刪除清單資料夾內之檔案路徑
        let fp = `${fdTag}/${fn}`

        //check, 若有檔案才刪除
        if (!fsIsFile(fp)) {
            return
        }

        //j
        let j = fs.readFileSync(fp, 'utf8')

        //o
        let o = JSON.parse(j)

        //fsDeleteFile
        let r = fsDeleteFile(fp)

        //check
        if (r.error) {
            throw new Error(r.error)
        }

        return o
    }

    // //releaseTagAdd
    // let releaseTagAdd = async (fn) => {
    //     let r = await releaseTagCore('add', fn)
    //     return r
    // }

    // //releaseTagModify
    // let releaseTagModify = async (fn) => {
    //     let r = await releaseTagCore('modify', fn)
    //     return r
    // }

    //releaseTagRemove
    let releaseTagRemove = async (fn) => {
        let r = await releaseTagCore('remove', fn)
        return r
    }

    //coreSrc
    let otkSrc = null
    let coreSrc = async() => {

        //因core執行初期ev尚未回傳給外部監聽, 故須delay延遲脫勾
        await delay(1)

        //ts
        let ts = ot()

        //calcTimeRun
        let calcTimeRun = () => {

            //te
            let te = ot()

            //s
            let s = te.diff(ts, 'second')

            //r
            let r = {
                timeRunStart: ts.format('YYYY-MM-DDTHH:mm:ssZ'),
                timeRunEnd: te.format('YYYY-MM-DDTHH:mm:ssZ'),
                timeRunSpent: `${s}s`,
            }

            return r
        }

        srlog.info({ event: 'start', msg: 'running...' })

        //msgExit
        let msgExit = ''

        //fsTaskCp
        let otkActual = fsTaskCp(fdTaskCpActualSrc, fdTaskCpActualSrc) //因不使用偵測端, 故設定fdTar=fdSrc

        //otkActualSrc
        let otkActualSrc = otkActual.buildSrc()
        // otkActualSrc.on('set', (msg) => {
        //     // console.log(`src send task...`, msg)
        // })
        // otkActualSrc.on('remove', (msg) => {
        //     // console.log(`src send task...`, msg)
        // })

        //fsTaskCp
        let otk = fsTaskCp(fdTaskCpSrc, fdTaskCpSrc) //因不使用偵測端, 故設定fdTar=fdSrc

        //otkSrc
        otkSrc = otk.buildSrc()
        // otkSrc.on('set', (msg) => {
        //     // console.log(`src send task...`, msg)
        // })
        // otkSrc.on('remove', (msg) => {
        //     // console.log(`src send task...`, msg)
        // })

        //itemsAtt
        let itemsAtt = []
        if (true) {
            try {

                //funDownload
                srlog.info({ event: 'proc-callfun-download', msg: 'start...' })
                let q = funDownload()
                if (ispm(q)) {
                    q = await q
                }
                srlog.info({ event: 'proc-callfun-download', num: size(q), msg: 'done' })

                //save
                itemsAtt = q

            }
            catch (err) {
                console.log(err)
                srlog.error({ event: 'proc-callfun-download', msg: getErrorMessage(err) })
                msgExit = 'error at proc-callfun-download'
            }
        }

        //check
        if (isestr(msgExit)) {
            console.log(`error occurred, task canceled`) //程序發生錯誤, 不進行後續動作
            srlog.info({ event: 'cancel', ...calcTimeRun(), msg: msgExit })
            return
        }

        //itemsCur
        let itemsCur = []
        if (true) {
            try {

                //funGetCurrent
                srlog.info({ event: 'proc-callfun-getCurrent', msg: 'start...' })
                let q = funGetCurrent()
                if (ispm(q)) {
                    q = await q
                }
                srlog.info({ event: 'proc-callfun-getCurrent', num: size(q), msg: 'done' })

                //save
                itemsCur = q

            }
            catch (err) {
                console.log(err)
                srlog.error({ event: 'proc-callfun-getCurrent', msg: getErrorMessage(err) })
                msgExit = 'error at proc-callfun-getCurrent'
            }
        }

        //check
        if (isestr(msgExit)) {
            console.log(`error occurred, task canceled`) //程序發生錯誤, 不進行後續動作
            srlog.info({ event: 'cancel', ...calcTimeRun(), msg: msgExit })
            return
        }

        //check
        if (size(itemsAtt) === 0) {
            console.log(`invalid data, task canceled`) //無法取得有效數據, 不進行後續動作
            srlog.info({ event: 'cancel', ...calcTimeRun(), msg: 'no data' })
            return
        }

        // //check
        // if (size(itemsCur) - size(itemsAtt) > 10) {
        //     console.log(`difference between the data before and after is too large, size(itemsCur)[${size(itemsCur)}]-size(itemsAtt)[${size(itemsAtt)}]>10`) //當前取得數據與已儲存數據之數量差距超過10, 不進行後續動作, 當前取得數據筆數[${size(itemsAtt)}], 已儲存數據筆數[${size(itemsCur)}]
        //     srlog.info({ event: 'cancel', ...calcTimeRun(), msg: 'difference between the data before and after is too large' })
        //     return
        // }

        //ltdtDiffByKey
        let r = null
        if (true) {
            try {

                srlog.info({ event: 'compare', msg: 'start...' })
                let ltdtSrc = itemsAtt
                // console.log('ltdtSrc', ltdtSrc)
                let ltdtTar = itemsCur
                // console.log('ltdtTar', ltdtTar)
                r = ltdtDiffByKey(ltdtTar, ltdtSrc, keyId, { withInfor: false })
                // console.log('ltdtDiffByKey', r)
                //   del: [ {...} ],
                //   add: [ {...} ],
                //   same: [ {...} ],
                //   diff: [ {...} ],
                srlog.info({ event: 'compare', msg: 'done' })

            }
            catch (err) {
                console.log(err)
                srlog.error({ event: 'compare', msg: getErrorMessage(err) })
            }
        }

        //check
        if (!iseobj(r)) {
            console.log(`can not calculate the difference, task canceled`) //無法計算當前取得與已儲存數據之差異, 不進行後續動作
            srlog.info({ event: 'cancel', ...calcTimeRun(), msg: 'can not calculate the difference between the data before and after' })
            return
        }

        //check
        if (size(r.del) === 0 &amp;&amp; size(r.add) === 0 &amp;&amp; size(r.diff) === 0) {
            //當前取得與已儲存數據無差異, 不進行後續動作
            srlog.info({ event: 'cancel', ...calcTimeRun(), msg: 'no difference' })
            return
        }

        //trigger del
        await pmSeries(r.del, async(v) => {

            //check
            if (isestr(msgExit)) {
                return
            }

            //funRemove
            try {
                srlog.info({ event: 'proc-remove-callfun-remove', [keyId]: v[keyId], msg: 'start...' })
                let q = funRemove(v)
                if (ispm(q)) {
                    q = await q
                }
                // srlog.info({ event: 'proc-remove-callfun-remove', [keyId]: v[keyId], msg: 'done' })
            }
            catch (err) {
                console.log(err)
                srlog.error({ event: 'proc-remove-callfun-remove', [keyId]: v[keyId], msg: getErrorMessage(err) })
                msgExit = 'error at proc-remove-callfun-remove'
            }

            //check
            if (isestr(msgExit)) {
                return
            }

            //remove
            try {

                //otkActualSrc.remove
                otkActualSrc.remove(v[keyId])
                if (timeToleranceRemove &lt;= 0) {
                    //若未給予刪除誤差

                    //otkSrc.remove
                    otkSrc.remove(v[keyId])

                    srlog.info({ event: 'proc-remove-callfun-remove', [keyId]: v[keyId], msg: 'done' })
                }
                else {
                    //若有給予刪除誤差

                    //checkTagRemove
                    let r = await checkTagRemove(v[keyId], { checkTime: false })

                    //check, 是否位於刪除清單內
                    if (r.b) {
                        //若位於刪除清單, 不呼叫tagRemove更新[刪除tag]
                    }
                    else {
                        //若位於刪除清單, 呼叫tagRemove新增[刪除tag]

                        //tagRemove
                        await tagRemove(v[keyId])

                        srlog.info({ event: 'proc-remove-callfun-remove', [keyId]: v[keyId], msg: 'tag' })
                    }

                }

            }
            catch (err) {
                console.log(err)
                srlog.error({ event: 'proc-remove-otkActual-remove', [keyId]: v[keyId], msg: getErrorMessage(err) })
                msgExit = 'error at proc-remove-otkActual-remove'
            }

        })

        //check
        if (isestr(msgExit)) {
            console.log(`error occurred, task canceled`) //程序發生錯誤, 不進行後續動作
            srlog.info({ event: 'cancel', ...calcTimeRun(), msg: msgExit })
            return
        }

        //trigger add
        await pmSeries(r.add, async(v) => {

            //check
            if (isestr(msgExit)) {
                return
            }

            //funAdd
            try {
                srlog.info({ event: 'proc-add-callfun-add', [keyId]: v[keyId], msg: 'start...' })
                let q = funAdd(v)
                if (ispm(q)) {
                    q = await q
                }
                // srlog.info({ event: 'proc-add-callfun-add', [keyId]: v[keyId], msg: 'done' })
            }
            catch (err) {
                console.log(err)
                srlog.error({ event: 'proc-add-callfun-add', [keyId]: v[keyId], msg: getErrorMessage(err) })
                msgExit = 'error at proc-add-callfun-add'
            }

            //check
            if (isestr(msgExit)) {
                return
            }

            //set
            try {

                //hash
                let hash = str2b64(JSON.stringify(v))

                //otkActualSrc.set
                otkActualSrc.set(v[keyId], hash)
                if (timeToleranceRemove &lt;= 0) {
                    //若未給予刪除誤差

                    //otkSrc.set
                    otkSrc.set(v[keyId], hash)

                    srlog.info({ event: 'proc-add-callfun-add', [keyId]: v[keyId], msg: 'done' })
                }
                else {
                    //若有給予刪除誤差

                    //checkTagRemove
                    let r = await checkTagRemove(v[keyId], { checkTime: false })

                    //check, 是否位於刪除清單內
                    if (r.b) {
                        //若位於刪除清單, 則呼叫releaseTagRemove清除[刪除tag]

                        //releaseTagRemove
                        await releaseTagRemove(v[keyId])

                        srlog.info({ event: 'proc-add-callfun-add', [keyId]: v[keyId], msg: 'release-tag' })
                    }
                    else {
                        //若非位於刪除清單, 則呼叫otkSrc.set

                        //otkSrc.set
                        otkSrc.set(v[keyId], hash)

                        srlog.info({ event: 'proc-add-callfun-add', [keyId]: v[keyId], msg: 'done' })
                    }

                }

            }
            catch (err) {
                console.log(err)
                srlog.error({ event: 'proc-add-otkActual-set', [keyId]: v[keyId], msg: getErrorMessage(err) })
                msgExit = 'error at proc-add-otkActual-set'
            }

        })

        //check
        if (isestr(msgExit)) {
            console.log(`error occurred, task canceled`) //程序發生錯誤, 不進行後續動作
            srlog.info({ event: 'cancel', ...calcTimeRun(), msg: msgExit })
            return
        }

        //trigger diff
        await pmSeries(r.diff, async(v) => {

            //check
            if (isestr(msgExit)) {
                return
            }

            //funModify
            try {
                srlog.info({ event: 'proc-diff-callfun-modify', [keyId]: v[keyId], msg: 'start...' })
                let q = funModify(v)
                if (ispm(q)) {
                    q = await q
                }
                // srlog.info({ event: 'proc-diff-callfun-modify', [keyId]: v[keyId], msg: 'done' })
            }
            catch (err) {
                console.log(err)
                srlog.error({ event: 'proc-diff-callfun-modify', [keyId]: v[keyId], msg: getErrorMessage(err) })
                msgExit = 'error at proc-diff-callfun-modify'
            }

            //check
            if (isestr(msgExit)) {
                return
            }

            //set
            try {

                //hash
                let hash = str2b64(JSON.stringify(v))

                //otkActualSrc.et
                otkActualSrc.set(v[keyId], hash)

                //otkSrc.et
                otkSrc.set(v[keyId], hash)

                srlog.info({ event: 'proc-diff-callfun-modify', [keyId]: v[keyId], msg: 'done' })
            }
            catch (err) {
                console.log(err)
                srlog.error({ event: 'proc-diff-otkActual-set', [keyId]: v[keyId], msg: getErrorMessage(err) })
                msgExit = 'error at proc-diff-otkActual-set'
            }

        })

        //check
        if (isestr(msgExit)) {
            console.log(`error occurred, task canceled`) //程序發生錯誤, 不進行後續動作
            srlog.info({ event: 'cancel', ...calcTimeRun(), msg: msgExit })
            return
        }

        //成功處理完畢, 將fdDwAttime儲存至fdDwCurrent
        if (true) {

            //fsCleanFolder
            fsCleanFolder(fdDwCurrent)

            //fsCopyFolder
            let r = fsCopyFolder(fdDwAttime, fdDwCurrent)

            //check
            if (r.error) {
                console.log(r.error)
                srlog.error({ event: 'task-update-rawData', msg: r.error })
                msgExit = 'error at task-update-rawData'
                return
            }

        }

        //check
        if (isestr(msgExit)) {
            console.log(`error occurred, task canceled`) //程序發生錯誤, 不進行後續動作
            srlog.info({ event: 'cancel', ...calcTimeRun(), msg: msgExit })
            return
        }

        srlog.info({ event: 'end', ...calcTimeRun(), msg: 'done' })

    }

    let pmSrc = coreSrc()
        .catch((err) => {
            console.log(err)
            srlog.error({ event: 'proc-coreSrc', msg: getErrorMessage(err) })
        })

    let coreDetect = async() => {

        //wait
        await waitFun(() => {
            return otkSrc !== null
        })

        //timeNow
        let timeNow = ot()

        //vfpsRemove
        let vfpsRemove = fsTreeFolder(fdTagRemove, 1)

        // //vfpsModify
        // let vfpsModify = fsTreeFolder(fdTagModify, 1)

        //check
        // if (size(vfpsRemove) === 0 &amp;&amp; size(vfpsModify) === 0) {
        //     return
        // }
        if (size(vfpsRemove) === 0) {
            return
        }

        await pmSeries(vfpsRemove, async(v) => {

            //checkTagRemove
            let r = await checkTagRemove(v.name, { timeNow, checkTime: true }) //v.name對應v[keyId]

            //check, 刪除任務之時間是否已超過容許值門檻
            if (r.b) {
                //時間差已超過容許值門檻, 則呼叫releaseTagRemove清除[刪除tag], 與呼叫otkSrc.remove

                await releaseTagRemove(v.name) //v.name對應v[keyId]

                srlog.info({ event: 'proc-detect-remove', [keyId]: v.name, from: 'debounce', msg: 'release-tag' })

                otkSrc.remove(v.name) //v.name對應v[keyId]

                srlog.info({ event: 'proc-detect-remove', [keyId]: v.name, from: 'debounce', msg: 'done' })

            }
            else {
                //時間差未超過容許值門檻, 不處理
            }

        })

        // await pmSeries(vfpsModify, async(v) => {

        //     //checkTagModify
        //     let r = await checkTagModify(v.name, { timeNow, checkTime: true }) //v.name對應v[keyId]

        //     //check, 變更任務之時間是否已超過容許值門檻
        //     if (r.b) {

        //         //時間差已超過容許值門檻, 則須呼叫releaseTagModify偵測與清除變更tag, 再呼叫otkSrc.set
        //         let rModify = await releaseTagModify(v.name)
        //         otkSrc.set(v.name, rModify.hash) //v.name對應v[keyId]

        //         srlog.info({ event: 'proc-diff-modify', [keyId]: v.name, from: 'debounce', msg: 'done' })

        //     }
        //     else {
        //         //時間差未超過容許值門檻, 不處理
        //     }

        // })

    }

    let pmDetect = coreDetect()
        .catch((err) => {
            console.log(err)
            srlog.error({ event: 'proc-coreDetect', msg: getErrorMessage(err) })
        })

    //save
    ev.srlog = srlog

    //emit end
    Promise.all([pmSrc, pmDetect])
        .finally(() => {
            ev.emit('end')
        })

    return ev
}


export default WDwdataBuilder
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.4</a> on Mon Sep 01 2025 12:39:48 GMT+0800 (台北標準時間) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
